---
layout:     post
title:      "ssh协议的学习与理解"
subtitle:   "ssh协议"
author:     "Sone"
header-img: "img/post-bg-js-version.jpg"
tags:
    - ssh协议
---
### 操作步骤
#### ssh用于远程登陆
ssh -p 22 user@host //以用户名user登陆远程主机host 默认端口为22，使用p参数，可以修改端口

ssh host //如果本地用户名和远程用户名一直，可以省略用户名

当使用ssh客户端连接服务器时会发出一个warning
```
Warning: the ECDSA(椭圆曲线数字签名算法：公私钥加密原理) host key for 'hellobirds.top' differs from the key for the IP address '47.93.249.144'
Offending（不愉快的，厌恶的，冒犯） key for IP in /c/Users/Administrator/.ssh/known_hosts:4 
Matching（匹配） host key in /c/Users/Administrator/.ssh/known_hosts:6
Are you sure you want to continue connecting (yes/no)?

```
[ECDSA](http://blog.csdn.net/sszgg2006/article/details/25478269)
[公钥(pubkey)、私钥(privkey)](http://8btc.com/thread-31041-1-1.html)

#### 免密码连接服务器（使用Public Key方式
1. 客户端：使用ssh-keygen 指令生成一对密钥（公钥.pub后缀和私钥：无后缀），windows默认在C:\Users\Administrator\\.ssh目录,linux默认在用户的根目录~中，linux系统中.ssh文件是隐藏的 ，使用ll -a指令查看隐藏的文件

> note : 如果服务器端没有.ssh文件，可以使用ssh-keygen生成一个服务端自己的密钥，这时该指令就会自动创建一个.ssh文件了

2. 将客户端生成的公钥拷贝到服务器端的authorized_keys中，可以使用该指令直接将客户端的公钥copy到服务端`ssh-copy-id -i ~/.ssh/id_rsa.pub root@110.110.110`

3. 在xShell客户端界面中进入File>Authentication界面，Method选择Public Key，然后将上一步保存至服务器中的公钥所对应的本地的私钥导入到User Key选项中，点击Ok，即可免密码直接连接至服务器。

#### 服务器端启用密钥认证登陆，关闭密码认证方式登陆

可以使系统更安全
1. 修改服务端ssh配置
 ```
 vim /etc/ssh/sshd_config
 PubkeyAuthentication  yes  #启用PublicKey认证。
 AuthorizedKeysFile       .ssh/authorized_keys  #PublicKey文件路径。
 PasswordAuthentication  no  #不使用密码认证登录。

 配置完成，保存，并重启sshd服务 service ssh restart


 ssh user@host 'mkdir -p .ssh && cat >> .ssh/authorized_keys' < ~/.ssh/id_rsa.pub
 
 "$ mkdir -p .ssh"的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；
 'cat >> .ssh/authorized_keys' < ~/.ssh/id_rsa.pub的作用是，将本地的公钥文件~/.ssh/id_rsa.pub，重定向追加到远程文件authorized_keys的末尾。
 如果是刚刚创建 ~/.ssh/authorized_keys 的话, 要注意该文件的权限, 可以改成如: chmod 640 ~/.ssh/authorized_keys

 ```
#### 何为数字签名

假设a在（自己电脑上）客户端生成了一对密钥，将公钥copy放到了他的阿里云服务器上。

阿里云服务器和a的电脑通信步骤：
1. 使用公钥将信息加密，发送给a
2. a收到信后，用私钥解密就看到了信息。只要a的私钥不泄露，传递的信息就是安全的，即使被别人截获，其他人没有私钥也无法解密。

a的电脑和阿里云服务器通信
1. a将所发送的信息使用Hash函数，生成信息的摘要（digest）。
2. a使用私钥，对这个摘要进行加密，生成“数字签名”(signature)
3. a将这个签名附在信息下面，发送给阿里云
4. 阿里云收到信息后，取下数字签名。用公钥解密，得到信息的摘要。这样就可以确认信息是a发出的
5. 阿里云再对信息本身使用Hash函数，将得到的结果与上一步得到的摘要进行对比，如果两者一致，就证明这封信未被修改过

#### 何为数字证书
证书中心 certificate authority 简称CA。为公钥做认证。证书中心用自己的私钥，对a的公钥和一些相关信息一起加密，生成"数字证书"（Digital Certificate）。

a拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。

阿里云收信后，用CA的公钥解开数字证书，就可以拿到a真实的公钥了，然后就能证明"数字签名"是否真的是鲍勃签的。

#### 数字证书的应用实例
https协议，主要用于网页加密

客户端---（a request for a secure connection）服务器（a response of encrypted webpage with certificate）
1. 客户端向服务器发出加密请求

2. 服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。

3. 客户端（浏览器）的"证书管理器"，有"受信任的根证书颁发机构"列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。

4. 如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。

5. 如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。

6. 如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。




所谓"公钥登录"，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段用用户公钥加密的随机字符串，用户用自己的私钥解密后，再发回来。远程主机把这个信息和原始信息匹配，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。（其实，用户用私钥解密之后得到原始信息X，还要用会话号P和X一起算md5发回给服务器，服务器用之前保存的会话号P和原始信息X做md5运算，和用户发回的信息匹配，如果成功，就证明用户是可信的）

如果远程主机上面有多个公钥，那它选择那个公钥来对数据进行加密呢?但是如果发送的是明文，用户用私钥加密，发送到远程主机，远程主机就可以遍历公钥来对数据解密了。不要说远程主机会遍历公钥来对数据加密发送给用户啊，这明显是浪费时间的。

公私钥是对等的吧，公加私解或者私加公解都只是用法问题

明显身份认证的时候私加公解划算啊。

自从kernel.org被爆，现在多数改为公钥认证方式，password我平时只用在内网服务器。不过像VPS，如果开password认证，从auth.log可以看到，经常有人在试你密码。

ssh（ssl/tls）的原理很复杂，如果不对网络安全和数学有深入研究，很难讲得清楚。

口令登陆ssh遵循公钥加密、公钥解密;win客户端登陆 ①向远端主机发送请求 ②远程主机发给win客户一个公钥(类似一个没有上锁的盒子),win客户将密码放入上锁后再次还给远程主机 ③远程主机用私钥打开公钥(盒子),验证密码一致允许登陆。
ssh公钥登陆同样遵循私钥加密、公钥解密;linux客户端先生成ssh公钥事先给远程主机更名为authorized_keys，①linux客户端向远程主机发送连接,远程主机随意发给linux客户端一串字符串 ②linux客户端用私钥加密字符串返还给远程主机 ③远程主机用事先存储的公钥进行解密,如果和事先发送的字符串一致则允许登陆。

所谓"公钥登录"，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。

当需要连接到SSH服务器上时，客户端软件就会向服务器发出请求，请求使用客户端的密钥进行安全验证。服务器收到请求之后，先在该用户的根目录下寻找共有密钥，然后把它和发送过来的公有密钥进行比较。如果两个密钥一致，服务器就用公有的密钥加密“质询”，并把它发送给客户端软件（putty,xshell等）。客户端收到质询之后，就可以用本地的私人密钥解密再把它发送给服务器，这种方式是相当安全的。

公钥和私钥本身都是既可以加密也可以解密的，公钥加密私钥解密是正常的非对称加密过程，私钥加密公钥解密应该就是数字签名的过程了。

（1）通常术语上私钥加密说成签名，公钥解密说成验签。从数学上是类似操作，但用途上签名和验签是为了证明“对方是对方”，而加密和解密是为了“发来的信息没被人偷看”，更严谨的安全会话是加密和签名同时用，因为正如您说的加密不能证明发消息的人是靠谱的。
（2）客户端与服务器是多对1的关系。“远程主机用事先储存的公钥进行解密”，如何从一堆公钥中找到当前客户端的公钥，少了一个公钥索引的点。

公钥登陆部分，是客户端将自己的公钥发送到服务端，服务端用客户端的公钥加密一个256位的随机字符串，客户端接收后解密，然后将这个字符串和会话标识符合并在一起，对结果应用MD5散列函数并把散列值返回给服务器，服务器进行相同的MD5散列函数，如果客户端和该值可以匹配，那么匹配成功。

很详细，确实是这样的。关于会话标识符想说的一点是客户端与服务器实际上是先有会话加密过程，再进行的客户端验证，所以这个会话标识符就是第一个阶段生成的共享密钥。

- client向server端请求（用户A想访问server系统下的账户B）,该请求中包含public-key的modulus
- server读取B账户，查找是否存在匹配的public-key。如果不存在，请求失败。
- server端生成一个256 bit的字符串，用匹配的public-key加密发给client
- client端用自己的私钥解密数据，然后和当前的session identifier HASH生成md5值发给server
- server重新计算md5值，跟client进行比较

当客户端希望通过SSH KEY 鉴权登录时，它会告诉服务端，并附带上自己的公钥KEY信息。服务端检查它的KEY文件，同时生成一个随机串，并且用公钥加密。加密过的随机串，只有客户端用自己的私钥才可以解。
一旦收到消息，客户端将用自己的私钥解密，获取到随机串，同时，将先前跟服务端商定的SESSIONID一起，再次做MD5一致性HASH（md5(randomKey,sessionId），发回给服务端。服务端也按同样的方式生成摘要，如果两者一致，则验证通过。

所谓"公钥登录"，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。


### SSH是每一台Linux电脑的标准配置。

> SSH 为 Secure Shell 的缩写,中文名：安全外壳协议，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。

ssh是一个安全协议，可以有效防止远程连接过程中的信息泄漏问题。

ssh协议最初是unix系统上的一个程序，现在linux等平台都可运行ssh。

传统的网络服务程序，如：ftp、pop和telnet在本质上都是不安全的，因为它们在网络上用明文传送口令和数据，别有用心的人非常容易就可以截获这些口令和数据。

由于使用linux时，大部分情况需要远程连接，使用ssh协议可以保证数据传输过程中的安全性，因此我们需要学习并掌握ssh的原理。


服务器--中间人--客户端


### 中间人的攻击方式
传统的网络服务程序容易遭到中间人的攻击。

中间人冒充真正的服务器接受你传送给服务器的数据。

然后再冒充你把真正的数据传递到服务器。这样等同于你的数据被中间人做了手脚，或者被中间人窃取，因此传统的网络服务程序变的很不安全

### 为什么使用SSH

ssh可以把传输的数据进行加密，这样，中间人的攻击方式就不好实现了。也能够防止DNS欺骗和IP欺骗。

ssh有一个额外的好处，它传输的数据是经过压缩的 ，因此可以加快传输速度。

ssh还有许多功能，可以替代Telnet，又可以为ftp、pop、ppp提供一个安全的通道。


### 客户端使用ssh协议访问服务器的验证方式
ssh提供两种级别的安全验证：

1. 基于口令的安全验证：

即使用账号和密码登陆到远程主机，但这种方式却不能保证你正在连接的服务器就是你想连接的服务器。可能会有别的服务器在冒充真正的服务器，即可能遭到中间人的攻击

2. 基于密钥的安全验证（公钥加密私钥解密）

需要创建一对密钥（包括公钥和私钥），同时将公钥放到服务器上，私钥保存在自己的电脑上（windows一般在：C:\Users\Administrator\.ssh\id_rsa私钥 && id_rsa_pub公钥）。

当你在客户端使用ssh连接服务器时，例如：使用客户端软件（eg:xShell ssh://root@xxx.com||服务器ip:22）连接服务器时，xShell会向服务器发出请求，请求用你的密钥进行安全验证。

服务器收到请求后，先在该服务器上你的主目录下寻找你的公钥，然后把它和你发来的公钥进行比较。如果两个公钥一致，服务器会用公钥加密‘质询challenge’并把它发送给xShell。

xShell收到‘质询’后就可以用你的私人密钥解密再把它发送给服务器。

因此，你必须知道该公钥对应的密钥是什么。与第一种级别相比，第二种级别不需要在网络上传送口令。

第二种级别不仅加密所有传送的数据，而且“中间人”这种攻击方式也是不可能的（因为他没有你的私匙）。但是整个登录的过程可能需要较长时间（eg：10秒 ）。

### 详细
如果你考察一下接入ISP(Internet Service Provider，互联网服务供应商)或大学的方法，一般都是采用Telnet或POP邮件客户进程。因此，每当要进入自己的账号时，你输入的密码将会以明码方式发送(即没有保护，直接可读)，这就给攻击者一个盗用你账号的机会—最终你将为他的行为负责。由于SSH的源代码是公开的，所以在Unix世界里它获得了广泛的认可。Linux其源代码也是公开的，大众可以免费获得，并同时获得了类似的认可。这就使得所有开发者(或任何人)都可以通过补丁程序或b u g修补来提高其性能，甚至还可以增加功能。开发者获得并安装SSH意味着其性能可以不断提高而无须得到来自原始创作者的直接技术支持。SSH替代了不安全的远程应用程序。SSH是设计用来替代伯克利版本的r命令集的；它同时继承了类似的语法。其结果是，使用者注意不到使用SSH和r命令集的区别。利用它，你还可以干一些很酷的事。通过使用SSH，你在不安全的网络中发送信息时不必担心会被监听。你也可以使用POP通道和Telnet方式，通过SSH可以利用PPP通道创建一个虚拟个人网络( Virtual Private Network,VPN)。SSH也支持一些其他的身份认证方法，如Kerberos和安全ID卡等。
但是因为受版权和加密算法的限制，可以预计将来会有越来越多的人使用SSH而不是Telnet或者POP3等。

### 层次
SSH 主要由三部分组成：

传输层协议 [SSH-TRANS]

提供了服务器认证，保密性及完整性。此外它有时还提供压缩功能。 SSH-TRANS 通常运行在TCP/IP连接上，也可能用于其它可靠数据流上。 SSH-TRANS 提供了强力的加密技术、密码主机认证及完整性保护。该协议中的认证基于主机，并且该协议不执行用户认证。更高层的用户认证协议可以设计为在此协议之上。

用户认证协议 [SSH-USERAUTH]

用于向服务器提供客户端用户鉴别功能。它运行在传输层协议 SSH-TRANS 上面。当SSH-USERAUTH 开始后，它从低层协议那里接收会话标识符（从第一次密钥交换中的交换哈希H ）。会话标识符唯一标识此会话并且适用于标记以证明私钥的所有权。 SSH-USERAUTH 也需要知道低层协议是否提供保密性保护。

连接协议 [SSH-CONNECT]

将多个加密隧道分成逻辑通道。它运行在用户认证协议上。它提供了交互式登录话路、远程命令执行、转发 TCP/IP 连接和转发 X11 连接。

结构编辑
SSH是由客户端和服务端的软件组成的，有两个不兼容的版本分别是：1.x和2.x。 用SSH 2.x的客户程序是不能连接到SSH 1.x的服务程序上去的。OpenSSH 2.x同时支持SSH 1.x和2.x。
服务端是一个守护进程(daemon)，他在后台运行并响应来自客户端的连接请求。服务端一般是sshd进程，提供了对远程连接的处理，一般包括公共密钥认证、密钥交换、对称密钥加密和非安全连接。
客户端包含ssh程序以及像scp（远程拷贝）、slogin（远程登陆）、sftp（安全文件传输）等其他的应用程序。
他们的工作机制大致是本地的客户端发送一个连接请求到远程的服务端，服务端检查申请的包和IP地址再发送密钥给SSH的客户端，本地再将密钥发回给服务端，自此连接建立。SSH 1.x和SSH 2.x在连接协议上有一些差异。
一旦建立一个安全传输层连接，客户机就发送一个服务请求。当用户认证完成之后，会发送第二个服务请求。这样就允许新定义的协议可以与上述协议共存。连接协议提供了用途广泛的各种通道，有标准的方法用于建立安全交互式会话外壳和转发（“隧道技术”）专有 TCP/IP 端口和 X11 连接。
SSH被设计成为工作于自己的基础之上而不利用超级服务器(inetd)，虽然可以通过inetd上的tcpd来运行SSH进程，但是这完全没有必要。启动SSH服务器后，sshd运行起来并在默认的22端口进行监听（你可以用 # ps -waux | grep sshd 来查看sshd是否已经被正确的运行了）如果不是通过inetd启动的SSH，那么SSH就将一直等待连接请求。当请求到来的时候SSH守护进程会产生一个子进程，该子进程进行这次的连接处理[4]  。

扩展编辑
SSH协议框架中设计了大量可扩展的冗余能力，比如用户自定义算法、客户自定义密钥规则、高层扩展功能性应用协议。这些扩展大多遵循 IANA 的有关规定，特别是在重要的部分，像命名规则和消息编码方面。
SSH采用面向连接的TCP协议传输 应用22号端口 安全系数较高。

SSH安全技巧编辑
SSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。S S H最初是U N I X系统上的一个程序，后来又迅速扩展到其他操作平台。S S H在正确使用时可弥补网络中的漏洞。客户端包含ssh程序以及像scp(远程拷贝)、slogin(远程登陆)、sftp(安全文件传输)等其他的应用程序。SSH有很多非常酷的特性，如果它是你每天的工作伴侣，那么我想你有必要了解以下10条高效使用SSH的秘籍，它们帮你节省的时间肯定会远远大于你用来配置它们的时间。

服务器间跳转

　　有些时候，你可能没法直接连接到某台服务器，而需要使用一台中间服务器进行中转，这个过程也可以自动化。首先确保你已经为服务器配置了公钥访问，并开启了agent forwarding，可以通过2条命令来连接目标服务器，不会有任何提示输入：
　　$ ssh gateway
　　gateway $ ssh db
　　然后在你的本地SSH配置中，添加下面这条配置：
　　Host db
　　HostName
　　ProxyCommand ssh gateway netcat -q 600 %h %p
　　可以通过一条命令来直接连接目标服务器了:
　　$ ssh db
　　这里你可能会需要等待长一点的时间，因为SSH需要进行两次认证，注意netcat也有可能被写成nc或者ncat或者前面还需要加上g，你需要检查你的中间服务器来确定实际的参数。
省去用户名

　　如果你在远程服务器上的用户名和你本地的用户名不同，你同样可以在SSH配置中进行设置：
　　Host www* mail
　　HostName %h
　　User simon
　　就算我的本地用户名是 smylers，我仍然可以这样连接我的服务器：
　　$ ssh www2
　　SSH会使用simon账户连接你的服务器，同样，Putty可以保存这个信息在你的session中。
主机别名

　　你也可以在你的SSH配置中直接定义主机别名，就像下面这样：
　　Host dev
　　HostName
　　你还可以使用通配符来进行分组：
　　Host dev intranet backup
　　HostName %h
　　Host www* mail
　　HostName %h
　　在Putty中你可以为每个主机名保存单独的session，然后双击建立连接(但是它可能没办法支持通配符)。
省略主机名
输入服务器的完整主机名来建立一个新的SSH连接实在是太乏味无聊了，尤其是当你有一组拥有相同域名但是子域名不同的服务器需要管理时。
　　或许你的网络已经配置了可以直接使用短域名，比如intranet，但是如果你的网络不支持，实际上你可以自己搞定这个问题，而不用求助网络管理员。
　　解决办法根据你用的操作系统而略有差异，下面是我的Ubuntu系统的配置：
　　prepend domain-search
然后你需要重启网络:$ sudo restart network-manager
　　不同的系统，这两条命令可能会略有差异。
连接中转
有时候你可能需要从一个服务器连接另外一个服务器，比如在两个服务器之间直接传输数据，而不用通过本地电脑中转：
　　www1 $ scp -pr templates www2:$PWD
　　(顺便说一下，当你需要在两台服务器间拷贝文件时，$PWD变量时非常有用的)，因为即使你已经在两台服务器上添加了你本地电脑的公钥，scp默认仍然会提示你输入密码：这是因为你用来作为跳板的那台服务器上并没有你的私钥，所以，第二台服务器会拒绝你的公钥，但是一定不要通过将你的私钥拷贝到中转服务器上来解决这个问题，你可以使用agent forwarding来解决这个问题，只要在你的.ssh/config文件中加入下面这行代码就可以了：ForwardAgent yes或者是在Putty中勾上“Allow agent forwarding”选项，本地SSH就变成了第一台服务器的SSH代理，从第一台服务器在连接其它服务器就变和和在你本地一样简单，注意，如果要开启这个选项，前提是这个中间服务器值得你信任。
别再输入密码
如果你还在通过密码方式登录SSH，那么你或许应该试试SSH Keys，首先使用OpenSSH为自己生成一对密钥：
　　$ ssh-keygen
　　跟随指示，完成之后，你应该可以在你的.ssh目录下看到两个文件，id_rsa就是你的私钥，而id_ras.pub则是你的公钥，现　在你需要将你的公钥拷贝到服务器上，如果你的系统有ssh-copy-id命令，拷贝会很简单：
　　$ ssh-copy-id
否则，你需要手动将你的公钥拷贝的服务器上的~/.ssh/authorized_keys文件中：
　　$ < ~/.ssh/id_rsa.pub ssh ‘mkdir -p .ssh; cat >> .ssh/authorized_keys; chmod go-w .ssh .ssh/authorized_keys’
　　试试重新连接到SSH服务器，或是拷贝文件，是不是已经不需要再输入密码了?
长连接
如果你发现自己每条需要连接同一个服务器无数次，那么长连接选项就是为你准备的：
　　ControlPersist 4h
　　你每次通过SSH与服务器建立连接之后，这条连接将被保持4个小时，即使在你退出服务器之后，这条连接依然可以重用，因此，在你下一次(4小时之内)登录服务器时，你会发现连接以闪电般的速度建立完成，这个选项对于通过scp拷贝多个文件提速尤其明显，因为你不在需要为每个文件做单独的认证了。
多条连接共享
如果你需要在多个窗口中打开到同一个服务器的连接，而不想每次都输入用户名，密码，或是等待连接建立，那么你可以配置SSH的连接共享选项，在本地打开你的SSH配置文件，通常它们位于~/.ssh/config，然后添加下面2行：
　　ControlMaster auto
　　ControlPath /tmp/ssh_mux_%h_%p_%r
　　试试断开你与服务器的连接，并建立一条新连接，然后打开一个新窗口，再创建一条连接，你会发现，第二条连接几乎是在瞬间就建立好了。
　　Windows用户
　　如果你是Windows用户，很不幸，最流行的开源SSH客户端Putty并不支持这个特性，但是Windows上也有OpenSSH的实现，比如这个Copssh，如果你觉得下面的一些技巧对你很有帮助，或许你应该试试Copssh。
　　文件传输
　　连接共享不止可以帮助你共享多个SSH连接，如果你需要通过SFTP与服务器传输文件，你会发现，它们使用的依然是同一条连接，如果你使用的Bash，你会发现，你甚至SSH甚至支持Tab对服务器端文件进行自动补全，共享连接选项对于那些需要借助SSH的工具，比如rsync，git等等也同样有效。
加速连接

　　如果你确保你和某个服务器之间的连接是安全的(比如通过公司内网连接)，那么你就可以通过选择arcfourencryption算法来让数据传输更快一些：
　　Host dev
　　Ciphers arcfour
　　注意这个加速是以牺牲数据的“加密”性为代价的，所以如果你连接的是位于网上的服务器，千万不要打开这个选项，并且确保你是通过VPN建立的连接。
减少延迟
如果每次连接服务器都意味着你需要等待几十秒而无所事事，那么你或许应该试试在你的SSH配置中加入下面这条：
　　GSSAPIAuthentication no
　　如果这条命令有效的话，你应该通知你的系统管理员让他在服务器上禁用这个选项，这样其他人就不用再分别添加这条配置到它们的本地配置了。[5] 

socks5 编辑
SOCKS5 是一个代理协议，它在使用TCP/IP协议通讯的前端机器和服务器机器之间扮演一个中介角色，使得内部网中的前端机器变得能够访问Internet网中的服务器，或者使通讯更加安全。SOCKS5 服务器通过将前端发来的请求转发给真正的目标服务器， 模拟了一个前端的行为。在这里，前端和SOCKS5之间也是通过TCP/IP协议进行通讯，前端将原本要发送给真正服务器的请求发送给SOCKS5服务器，然后SOCKS5服务器将请求转发给真正的服务器。
