## 数据库层面的优化
### 相关概念
	1. 什么是数据库缓存
		- mysql等关系型数据库的数据都存储在磁盘中，再高并发场景下，业务应用对mysql的增删改查操作造成巨大的 I/O开销和查询压力，对数据库和服务器都是一种巨大的压力，为了解决此类问题，缓存数据的概念应运而生
	2. 为什么要使用缓存
		- 极大解决数据库服务器的压力
		- 提高应用数据的响应速度（直接将静态数据返回）
		- 常见的缓存形式：内存缓存，文件缓存
		- 缓存数据是为了让客户端很少甚至不访问数据库服务器进行数据的查询，高并发下，能最大程度的降低对数据库的访问压力
		- 用户请求 数据查询 连接数据库服务区并查询数据 将数据缓存起来（html 内存 json 序列化数据） 显示给客户端 
		- 用户再次请求 数据查询 直接从缓存中获取数据 显示给客户端（由于存在内存中，使得响应速度提升同时降低了对数据库服务器的压力）
		- 缓存方式的选择：尽量选择存储到内存中，降低io开销，这样性能是最高的
		- 缓存场景的选择：不经常修改的数据
		- 缓存数据的实时性： 如果数据改变了，缓存修改吗？不建议同步的去修改，频繁的操作缓存的话，也是服务器的一种开销，取决于应用场景，一般缓存一定的时间
		- 保证缓存数据的稳定性
	3. 使用mysql查询缓存
		- 用的不多，限制比较多
		- 极大的降低cpu的使用率
		- 开启查询缓存
			- 查询缓存可以看作是sql文本和查询结果的映射
			- 第二次查询的sql和第一次查询的sql完全相同，则会使用缓存
			- show status like `Qcache_hits`；查看命中次数
			- 表的结构或数据发生改变时，查询缓存中的数据不再有效
			- query_cache_type 0不使用 1使用 2按需使用 
			- query_cache_size 默认为0 ，查询缓存预留的内存 set global query_cache_size = 10m;
			- select SQL_NO_CACHE * from table; 
			- select SQL_CACHE * from table;
			- 清理缓存 
				- flush query cache清理查询缓存内存碎片	
				- reset query cache从查询缓存中移出所有查询
				- flush tables关闭所有打开的表，同时该操作将会清空查询缓存中的内容
	4. 使用memcache缓存	
		- 大并发情况下，会有大量请求涌入数据库层，对于数据库服务器的压力冲击很大，响应速度也会下降，因此添加中间缓存层
		- 分布式的告诉缓存系统，用以提升网站的访问速度，尤其对于一些大型、需要频繁访问数据库的网站访问速度提升效果十分显著
		- 高性能分布式的内存对象缓存系统，在内存里维护一个巨大的hash表
		- 流程：检查请求数据是否在memchche，过期概念..set(key,val,expires)
		- 通用的缓存机制：用查询方法名+参数作为查询时的key value对中的key值
		- memcache memcached两套不同的扩展，后者方法多一些		
	5. 使用redis缓存  
		- 与memchche的区别
			- 性能相差不大
			- 持久化
			- 复杂的数据结构，多种类的数据结构
			- 根据场景选择
			- redis vm特性	
			- memcache lru算法
			- redis依赖客户端实现分布式读写	
			- memcache没有数据冗余机制，不支持持久化，通常做缓存提升性能
			- memchahe 在并发场景下，用cas保证一致性，redis事务支持比较弱
			- redis用于数据量较小的高性能操作和运算上			- memcache用于在动态系统中减少数据库负载，提升性能，适合做缓存
	6. 缓存其他数据
		- Session	
			- 不建议存在mysql中，可以存入缓存中	
			- session_set_save_handler